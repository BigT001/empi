const mongoose = require('mongoose');

const connectionString = 'mongodb+srv://sta99175_db_user:n45LxR23xyyf7D9l@cluster0.w7fvrkw.mongodb.net/?appName=Cluster0';

/**
 * Auto-repair script for detected data consistency issues
 * This script attempts to fix common issues without data loss
 */
async function repairDataConsistency(options = {}) {
  const { autoFix = false, verbose = true } = options;

  try {
    await mongoose.connect(connectionString);
    const log = verbose ? console.log : () => {};
    
    log('üîß DATA CONSISTENCY REPAIR SCRIPT\n');
    log(`Mode: ${autoFix ? 'üî¥ AUTO-FIX' : 'üü¢ REPORT ONLY'}\n`);
    log('='.repeat(70) + '\n');

    const db = mongoose.connection.db;
    const issues = [];
    const repairs = [];

    // ============================================
    // REPAIR 1: Fix VAT Calculation Mismatches
    // ============================================
    log('üßæ Checking VAT calculations...\n');

    const expensesCol = db.collection('expenses');
    const expensesList = await expensesCol.find({}).toArray();

    let vatIssues = 0;
    for (const expense of expensesList) {
      if (expense.isVATApplicable !== false && expense.amount > 0) {
        const expectedVAT = Math.round((expense.amount * 0.075) * 100) / 100;
        const actualVAT = expense.vat || 0;

        if (Math.abs(expectedVAT - actualVAT) > 0.01) {
          vatIssues++;
          issues.push(`Expense ${expense._id}: VAT mismatch (expected ‚Ç¶${expectedVAT}, got ‚Ç¶${actualVAT})`);

          if (autoFix) {
            await expensesCol.updateOne(
              { _id: expense._id },
              { $set: { vat: expectedVAT, corrected: true, correctionDate: new Date() } }
            );
            repairs.push(`‚úÖ Fixed VAT for expense ${expense._id}`);
          }
        }
      }
    }

    if (vatIssues === 0) {
      log('   ‚úÖ All VAT calculations are correct\n');
    } else {
      log(`   ‚ö†Ô∏è Found ${vatIssues} VAT calculation issues\n`);
    }

    // ============================================
    // REPAIR 2: Fix Missing Order Numbers
    // ============================================
    log('üîë Checking for missing order numbers...\n');

    const ordersCol = db.collection('orders');
    const unifiedCol = db.collection('unifiedorders');

    const ordersWithoutNumbers = await ordersCol.find({ orderNumber: { $exists: false } }).toArray();
    const unifiedWithoutNumbers = await unifiedCol.find({ orderNumber: { $exists: false } }).toArray();

    const totalMissing = ordersWithoutNumbers.length + unifiedWithoutNumbers.length;

    if (totalMissing === 0) {
      log('   ‚úÖ All orders have order numbers\n');
    } else {
      log(`   ‚ö†Ô∏è Found ${totalMissing} orders without order numbers\n`);

      if (autoFix) {
        // Generate missing order numbers
        for (const order of ordersWithoutNumbers) {
          const orderNumber = `OFF-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          await ordersCol.updateOne(
            { _id: order._id },
            { $set: { orderNumber, autoGenerated: true, correctionDate: new Date() } }
          );
          repairs.push(`‚úÖ Generated order number for offline order ${order._id}`);
        }

        for (const order of unifiedWithoutNumbers) {
          const orderNumber = `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          await unifiedCol.updateOne(
            { _id: order._id },
            { $set: { orderNumber, autoGenerated: true, correctionDate: new Date() } }
          );
          repairs.push(`‚úÖ Generated order number for online order ${order._id}`);
        }
      }
    }

    // ============================================
    // REPAIR 3: Sync Invoices with Orders
    // ============================================
    log('üîó Checking invoice-order sync...\n');

    const invoicesCol = db.collection('invoices');
    const invoicesList = await invoicesCol.find({}).toArray();
    const [onlineOrders, offlineOrders] = await Promise.all([
      unifiedCol.find({}, { projection: { orderNumber: 1, total: 1, _id: 1 } }).toArray(),
      ordersCol.find({ isOffline: true }, { projection: { orderNumber: 1, total: 1, _id: 1 } }).toArray()
    ]);

    const orderMap = {};
    for (const order of [...onlineOrders, ...offlineOrders]) {
      if (order.orderNumber) {
        orderMap[order.orderNumber] = order;
      }
    }

    let orphanedInvoices = 0;
    let orphanedOrders = 0;

    for (const invoice of invoicesList) {
      if (!orderMap[invoice.orderNumber]) {
        orphanedInvoices++;
        issues.push(`Invoice ${invoice._id}: No matching order for ${invoice.orderNumber}`);

        if (autoFix) {
          await invoicesCol.deleteOne({ _id: invoice._id });
          repairs.push(`‚úÖ Deleted orphaned invoice ${invoice._id}`);
        }
      }
    }

    const invoiceOrderNumbers = new Set(invoicesList.map(i => i.orderNumber));
    for (const order of [...onlineOrders, ...offlineOrders]) {
      if (order.orderNumber && !invoiceOrderNumbers.has(order.orderNumber)) {
        orphanedOrders++;
        issues.push(`Order ${order.orderNumber}: No matching invoice`);

        if (autoFix) {
          const invoice = {
            orderNumber: order.orderNumber,
            orderId: order._id,
            totalAmount: order.total || 0,
            createdAt: new Date(),
            autoGenerated: true
          };
          const result = await invoicesCol.insertOne(invoice);
          repairs.push(`‚úÖ Created invoice for order ${order.orderNumber}`);
        }
      }
    }

    if (orphanedInvoices === 0 && orphanedOrders === 0) {
      log('   ‚úÖ All invoices and orders are properly synced\n');
    } else {
      log(`   ‚ö†Ô∏è Found sync issues: ${orphanedInvoices} orphaned invoices, ${orphanedOrders} orders without invoices\n`);
    }

    // ============================================
    // REPAIR 4: Validate Date Fields
    // ============================================
    log('üìÖ Checking date fields...\n');

    let invalidDates = 0;
    const allOrdersList = await Promise.all([
      unifiedCol.find({}).toArray(),
      ordersCol.find({}).toArray()
    ]);

    for (const orderList of allOrdersList) {
      for (const order of orderList) {
        if (order.createdAt && !(order.createdAt instanceof Date)) {
          invalidDates++;
          issues.push(`Order ${order._id}: Invalid createdAt format`);

          if (autoFix) {
            try {
              const date = new Date(order.createdAt);
              if (!isNaN(date.getTime())) {
                await (order.isOffline ? ordersCol : unifiedCol).updateOne(
                  { _id: order._id },
                  { $set: { createdAt: date } }
                );
                repairs.push(`‚úÖ Fixed date for order ${order._id}`);
              }
            } catch (e) {
              log(`   ‚ö†Ô∏è Could not parse date for ${order._id}`);
            }
          }
        }
      }
    }

    if (invalidDates === 0) {
      log('   ‚úÖ All date fields are valid\n');
    } else {
      log(`   ‚ö†Ô∏è Found ${invalidDates} invalid date fields\n`);
    }

    // ============================================
    // REPAIR 5: Check for Duplicate Order Numbers
    // ============================================
    log('üî¢ Checking for duplicate order numbers...\n');

    const allOrders = await Promise.all([
      unifiedCol.find({}, { projection: { orderNumber: 1 } }).toArray(),
      ordersCol.find({}, { projection: { orderNumber: 1 } }).toArray()
    ]);

    const orderNumbers = {};
    const duplicates = [];

    for (const orderList of allOrders) {
      for (const order of orderList) {
        if (order.orderNumber) {
          if (orderNumbers[order.orderNumber]) {
            duplicates.push({
              orderNumber: order.orderNumber,
              count: (orderNumbers[order.orderNumber] || 0) + 1
            });
            orderNumbers[order.orderNumber]++;
          } else {
            orderNumbers[order.orderNumber] = 1;
          }
        }
      }
    }

    if (duplicates.length === 0) {
      log('   ‚úÖ No duplicate order numbers\n');
    } else {
      log(`   ‚ö†Ô∏è Found ${duplicates.length} duplicate order numbers\n`);
      duplicates.forEach(dup => {
        issues.push(`Order number ${dup.orderNumber} appears ${dup.count} times`);
      });
    }

    // ============================================
    // SUMMARY
    // ============================================
    log('='.repeat(70) + '\n');
    log('üìã REPAIR SUMMARY\n');

    if (autoFix) {
      log(`   Total Issues Found: ${issues.length}`);
      log(`   Total Repairs Applied: ${repairs.length}\n`);

      if (repairs.length > 0) {
        log('   Applied Repairs:');
        repairs.forEach(repair => log(`   ${repair}`));
        log('');
      }
    } else {
      log(`   Issues Found: ${issues.length}\n`);

      if (issues.length > 0) {
        log('   Issues:');
        issues.slice(0, 10).forEach(issue => log(`   ‚Ä¢ ${issue}`));
        if (issues.length > 10) {
          log(`   ... and ${issues.length - 10} more\n`);
        } else {
          log('');
        }
        log('   üí° Tip: Run with --fix flag to auto-repair these issues\n');
      } else {
        log('   ‚úÖ No issues found!\n');
      }
    }

    console.log('='.repeat(70));

  } catch (error) {
    console.error('‚ùå Error:', error instanceof Error ? error.message : String(error));
    process.exit(1);
  } finally {
    await mongoose.disconnect();
  }
}

// Parse command line arguments
const args = process.argv.slice(2);
const autoFix = args.includes('--fix');

repairDataConsistency({ autoFix });
